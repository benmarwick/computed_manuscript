---
title: My Example Computed Manuscript
subtitle: Created in Rmarkdown
titlerunning: Example computed manuscript

authors: 
- name: Jeffrey M. Perkel
  address: Springer Nature, 1 New York Plaza, New York, NY
  email: jeffrey.perkel@nature.com
  
abstract: |
  A mock computed manuscript created in RStudio using {Rmarkdown}. The {Bookdown} and {Rticles} packages were used to output the text in Springer Nature's desired manuscript format. 

bibliography: bibliography.bib
biblio-style: spbasic
# bibstyle options spbasic(default), spphys, spmpsci
output: 
  bookdown::pdf_book:
    base_format: rticles::springer_article
    extra_dependencies: ["booktabs"]
---

```{r load-libraries, message=FALSE, include=FALSE}
library(dplyr)
library(magrittr)
library(tibble)
library(ggplot2)
library(bookdown)
```

# Introduction {#intro}

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

Here we'll add some references from Zotero [@perkel2020]: [@fisch_omics_2015; @argelaguet_computational_2021; @le_cao_community-wide_2021].

Markdown documents can include inline equations written in \LaTeX, such as $F = ma$. Here is an equation on its own line:

$$a^2 + b^2 = c^2$$

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

# Results {#results}

## Inline computation {#sec:1}

One 'killer feature' of computed manuscripts is the ability to compute and insert values into the text rather than requiring authors to input them manually. That circumvents the possibility that the author will enter an incorrect number, or forget to update them should new data arise. 

For instance, imagine we are analyzing data from a clinical trial:

```{r subject-weights, echo=FALSE}
# create a mock dataset
n_subjs <- 99
subjID <- 1:n_subjs

# generate 99 random #s between 1 and 10
tmp <- floor(runif(n_subjs, min = 1, max = 10))
# assign those numbers to any of 3 subject groups
fn <- function(x) { 
  if (x > 7) 'GRP_1' 
  else if (x > 5) 'GRP_2' 
  else 'GRP_3' 
}
subj_class <- sapply(tmp, fn)

# pick random weights between 75 and 300
wts <- floor(runif(n_subjs, min = 75, max = 300))
# combine the data into a table
df <- data.frame(ID = subjID, class = subj_class, wt = wts)

# display the table, splitting the 99 rows into 3 cols wide
tmp <- cbind(df[1:33,], rep('|', 33), 
             df[34:66,], rep('|', 33), 
             df[67:99,])
names(tmp) <- c('ID', 'class', 'wt', '|', 'ID', 'class', 'wt', 
                '|', 'ID', 'class', 'wt')
knitr::kable(tmp, format = 'latex', booktabs = TRUE, 
             caption = "Original subject data")
```

We have **`r nrow(df)`** subjects in our study (Table \@ref(tab:subject-weights)). The average weight is **`r round(mean(df$wt), 2)`** (range: **`r min(df$wt)`**-**`r max(df$wt)`**). We have **`r df %>% filter(class == 'GRP_1') %>% nrow()`** subjects in Group 1, **`r df %>% filter(class == 'GRP_2') %>% nrow()`** subjects in Group 2, and **`r df %>% filter(class == 'GRP_3') %>% nrow()`** in Group 3. (The numbers in **bold face type** are computed values.)

Now suppose we get another tranche of data:
```{r new-data, echo=FALSE}
# create a mock dataset
n_subjs <- 60
subjID <- 1:n_subjs

# generate 99 random #s between 0 and 10
tmp <- floor(runif(n_subjs, min = 0, max = 10))
# convert those numbers into either of 3 subject groups
subj_class <- sapply(tmp, fn)

wts <- floor(runif(n_subjs, min = 75, max = 300))
df2 <- data.frame(ID = subjID, class = subj_class, wt = wts)

# display the table, splitting the 99 rows into 3 cols wide
tmp <- cbind(df2[1:20,], rep('|', 20), 
             df2[21:40,], rep('|', 20), 
             df2[41:60,])
names(tmp) <- c('ID', 'class', 'wt', '|', 'ID', 'class', 'wt', 
                '|', 'ID', 'class', 'wt')
knitr::kable(tmp, format = 'latex', booktabs = TRUE, 
             caption = "New subject data")
```

There are **`r nrow(df2)`** subjects in this new dataset (Table \@ref(tab:new-data)). Their average weight is **`r round(mean(df2$wt), 2)`** (range: **`r min(df2$wt)`**-**`r max(df2$wt)`**). 

```{r combine-tables, echo=FALSE}
final_data <- rbind(df, df2)
```

Combining the two datasets, we have a total of **`r nrow(final_data)`** subjects. The revised average weight is **`r round(mean(final_data$wt), 2)`** (range: **`r min(final_data$wt)`**-**`r max(final_data$wt)`**). We now have **`r final_data %>% filter(class == 'GRP_1') %>% nrow()`** subjects in Group 1, **`r final_data %>% filter(class == 'GRP_2') %>% nrow()`** subjects in Group 2, and **`r final_data %>% filter(class == 'GRP_3') %>% nrow()`** in Group 3.

## The Fibonacci sequence {#sec:2}

```{r fibonacci, echo=FALSE, fig.cap="The first 26 numbers of the Fibonacci sequence", fig.height=3, fig.width=4}
# calculate the first `n` Fibonacci numbers
fibonacci <- function(n) {
  stopifnot(n > 2)
  ar <- rep(0, n)
  ar[1] <- f1 <- 0
  ar[2] <- f2 <- 1
  for (i in 3:n) {
    f3 <- f1 + f2
    ar[i] <- f3
    f1 <- f2
    f2 <- f3
  }
  return (ar)
}

ncalc <- 25
f <- fibonacci(ncalc)
df <- data.frame(1:ncalc, f)
names(df) <- c("x","y")

div <- 1000

p <- ggplot(df) +
  geom_line(aes(x, y/div), color = "red") +
  geom_point(aes(x, y/div), color = "blue") +
  scale_y_continuous(limits = c(0, max(df$y)/div)) +
  xlab("") +
  ylab("Fibonacci No. (thousands)") + 
  theme_minimal()
p
```

As Rmarkdown documents can do anything R can do, we can also create and include figures. For instance, we can calculate the first **`r ncalc`** numbers in the Fibonacci sequence. The data are shown in Figure \@ref(fig:fibonacci). Note that this figure number (as well as the table numbers above) are automatically generated. 

# Methods{#methods}

The following code was used in section \ref{sec:1} to create the original clinical trial data:

```{r show-trial-data-1, eval=FALSE, ref.label='subject-weights'}
```

The following code was used in section \ref{sec:2} to calculate and plot the Fibonacci sequence:

```{r show-fib-1, eval=FALSE, ref.label='fibonacci'}
```

# References
